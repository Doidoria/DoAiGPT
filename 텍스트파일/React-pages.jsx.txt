/* ==========================================================================
   File: SettingModal.jsx
   ========================================================================== */
// src/pages/SettingModal.jsx
import "../css/SettingModal.scss";
import useThemeMode from "../component/useThemeMode";

const SettingModal = ({ setShowSettingModal }) => {
    const { theme, toggleTheme } = useThemeMode();

    const handleDimClick = () => {
        setShowSettingModal(false);
    };

    const handleInnerClick = (e) => {
        e.stopPropagation();
    };

    return (
        <div className="setting_modal_dim" onClick={handleDimClick}>
            <div className="setting_modal_wrap" onClick={handleInnerClick}>
                <button
                    className="close_btn"
                    type="button"
                    onClick={() => setShowSettingModal(false)}
                >
                    <span className="material-symbols-outlined">close</span>
                </button>

                <h2>í™˜ê²½ ì„¤ì •</h2>

                <div className="theme_switch">
                    <p>í˜„ì¬ í…Œë§ˆ: {theme === "dark" ? "ğŸŒ™ Dark" : "â˜€ï¸ Light"}</p>
                    <button type="button" onClick={toggleTheme}>
                        {theme === "dark" ? "ë¼ì´íŠ¸ ëª¨ë“œë¡œ ì „í™˜" : "ë‹¤í¬ ëª¨ë“œë¡œ ì „í™˜"}
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SettingModal;


/* ==========================================================================
   File: Header.jsx
   ========================================================================== */
import '../../css/Layout/Header.scss'
import { useNavigate } from 'react-router-dom';

const Header = ({ isCollapsed, setIsCollapsed }) => {
  const navigate = useNavigate();
  const handleToggle = () => {
    setIsCollapsed(!isCollapsed);
  };

  const handleClose = () => {
    // window.close();
    // // (setTimeoutì„ ì“°ëŠ” ì´ìœ ëŠ” window.close()ê°€ ë¹„ë™ê¸°ë¡œ ì²˜ë¦¬ë  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤)
    // setTimeout(() => {
    //     if (!window.closed) {
    //         alert("ë¸Œë¼ìš°ì € ë³´ì•ˆ ì„¤ì •ìœ¼ë¡œ ì¸í•´ ì°½ì„ ë‹«ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    //     }
    // }, 100);

    // * ë¸Œë¼ìš°ì € ë³´ì•ˆ ì„¤ì • ëŒ€ì‹  ì ìš© *
    navigate('/goodbye');
  };

  return (
    <header>
      <div className="header_wrap">
        <button type="button" className="hamburger_btn" onClick={handleToggle}
          style={{ cursor: 'pointer' }}>
          <span className={isCollapsed ? 'material-symbols-outlined rotated' : 'material-symbols-outlined'}>menu</span>
        </button>
        <button type="button" style={{ cursor: 'pointer' }} onClick={handleClose}>
          <span className="material-symbols-outlined">close</span>
        </button>
      </div>
    </header>
  )
}
export default Header


/* ==========================================================================
   File: ChatRoom.jsx
   ========================================================================== */
// src/pages/ChatRoom.jsx
import '../css/ChatRoom.scss';
import { useState, useRef, useEffect, useCallback } from 'react';
import { useOutletContext, useParams, useLocation } from 'react-router-dom';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import useAutosizeTextarea from '../component/useAutosizeTextarea';
import useSpeechToText from '../component/useSpeechToText';
import axios from 'axios';

/* 3-dot typing animation */
const TypingDots = () => (
    <div className="typing_dots">
        <span></span>
        <span></span>
        <span></span>
    </div>
);

/* URL ì¶”ì¶œ (ì²« ë²ˆì§¸ ë§í¬ë§Œ) */
const extractFirstUrl = (text) => {
    if (!text) return null;
    const match = text.match(/https?:\/\/[^\s)]+/);
    return match ? match[0] : null;
};

// ìë™ ì–¸ì–´ ê°ì§€
const detectLanguage = (codeText) => {
    const sample = codeText.trim();

    if (/class\s+\w+|public\s+static|System\.out/.test(sample)) return "java";
    if (/def\s+\w+|import\s+\w+|print\(/.test(sample)) return "python";
    if (/function\s+\w+|const\s+\w+|let\s+\w+|=>/.test(sample)) return "javascript";
    if (/<[a-z]+[^>]*>/i.test(sample)) return "html";
    if (/{[\s\S]*}/.test(sample) && sample.includes(":")) return "json";
    if (/\.[a-z\-]+\s*\{/.test(sample)) return "css";
    if (/^\$[\w]/.test(sample)) return "bash";

    return "code"; // fallback
};

// ì½”ë“œë¸”ëŸ­ + ì¼ë°˜í…ìŠ¤íŠ¸ íŒŒì‹±
const renderRichText = (text, onCopyCode, role) => {
    if (!text) return null;

    const parts = text.split(/```/);

    return parts.map((part, idx) => {
        // í™€ìˆ˜ index = ì½”ë“œë¸”ëŸ­
        if (idx % 2 === 1) {
            const lines = part.split('\n');
            const first = lines[0]?.trim();

            const isLang = /^[a-zA-Z0-9_\-#+]+$/.test(first);
            const lang = isLang ? first : detectLanguage(part);
            const codeText = isLang ? lines.slice(1).join("\n") : part;

            // ë‚´ê°€ ë³´ë‚¸ ë©”ì‹œì§€ì¸ì§€ í™•ì¸
            const isUser = role === 'user';

            return (
                <div className="code_block" key={idx}>
                    <div className="code_header">
                        <span className="code_lang_label">{lang || 'CODE'}</span>
                        <button
                            type="button"
                            className="code_copy_btn"
                            onClick={() => onCopyCode(codeText)}
                        >
                            <span className="material-symbols-outlined">content_copy</span>
                            <span>ë³µì‚¬</span>
                        </button>
                    </div>

                    {/* Wrapper div ì œê±° -> SyntaxHighlighterì— ì§ì ‘ ìŠ¤íƒ€ì¼ ì£¼ì… */}
                    <SyntaxHighlighter
                        style={isUser ? {} : vscDarkPlus}
                        language={lang || 'javascript'}
                        PreTag="pre"
                        customStyle={{
                            margin: 0,
                            padding: '15px',
                            background: 'transparent',
                            borderRadius: 0,
                            fontSize: '14px',
                            lineHeight: '1.5',
                            // â–¼â–¼â–¼ ì—¬ê¸°ì— ì§ì ‘ ê°•ì œ ì ìš© (ê°€ì¥ í™•ì‹¤í•¨) â–¼â–¼â–¼
                            maxHeight: isUser ? '150px' : 'none',
                            overflowY: isUser ? 'auto' : 'hidden',
                            overflowX: 'auto',
                        }}
                    >
                        {String(codeText).replace(/\n$/, '')}
                    </SyntaxHighlighter>
                </div>
            );
        }

        // ì¼ë°˜ í…ìŠ¤íŠ¸
        return (
            <div className="text_block markdown_body" key={idx}>
                <ReactMarkdown remarkPlugins={[remarkGfm]}>
                    {part}
                </ReactMarkdown>
            </div>
        );
    });
};

const CHAT_API_URL = 'http://localhost:3001/api/chat';

const ChatRoom = () => {
    const { id: urlChatId } = useParams();
    const location = useLocation();
    const scrollRef = useRef(null);
    const textareaRef = useRef(null);
    const { scrollAreaRef } = useOutletContext();

    const [message, setMessage] = useState('');
    const [loading, setLoading] = useState(false);
    const [files, setFiles] = useState([]);
    const [isDragging, setIsDragging] = useState(false);
    const [previewImage, setPreviewImage] = useState(null);
    const [showScrollDown, setShowScrollDown] = useState(false);
    const { text, setText, isListening, startListening, stopListening } = useSpeechToText();

    const initialFiles = location.state?.initialFiles || [];

    const {
        activeChatId,
        setActiveChatId,
        chatRooms,
        setChatRooms,
    } = useOutletContext();

    useAutosizeTextarea(textareaRef, message);

    // í˜„ì¬ ì±„íŒ…ë°©ì˜ ëŒ€í™” ëª©ë¡
    const currentChats = urlChatId
        ? chatRooms[urlChatId]?.history || []
        : [];

    // ì²˜ìŒ ë“¤ì–´ì™”ì„ ë•Œ activeChatId ì„¸íŒ…
    useEffect(() => {
        if (urlChatId && setActiveChatId) {
            setActiveChatId(urlChatId);
        }
    }, [urlChatId, setActiveChatId]);

    // ë©”ì¸ì—ì„œ ë„˜ì–´ì˜¨ íŒŒì¼ë“¤ ì´ˆê¸° ì„¸íŒ…
    useEffect(() => {
        if (initialFiles.length > 0) {
            setFiles(initialFiles);
        }
    }, [initialFiles]);

    // ìƒˆ ë©”ì‹œì§€ ì˜¤ë©´ ìë™ ìŠ¤í¬ë¡¤
    useEffect(() => {
        if (scrollRef.current) {
            scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
        }
    }, [currentChats]);

    // ìŠ¤í¬ë¡¤ ìƒíƒœ ê°ì§€ (ë§¨ ì•„ë˜ ì—¬ë¶€)
    useEffect(() => {
        const el = scrollAreaRef.current;
        if (!el) return;

        const handleScroll = () => {
            const isBottom = el.scrollHeight - el.scrollTop <= el.clientHeight + 20;
            setShowScrollDown(!isBottom);
        };

        el.addEventListener("scroll", handleScroll);
        return () => el.removeEventListener("scroll", handleScroll);
    }, []);

    // ìŠ¤í¬ë¡¤ ë§¨ ì•„ë˜ë¡œ
    const scrollToBottom = () => {
        if (scrollAreaRef.current) {
            scrollAreaRef.current.scrollTo({
                top: scrollAreaRef.current.scrollHeight,
                behavior: "smooth"
            });
        }
    };

    const handleInputChange = useCallback((e) => {
        setMessage(e.target.value);
    }, []);

    const handleKeyDown = (e) => {
        // Enterë§Œ ëˆ„ë¥´ë©´ ì „ì†¡, Shift+EnterëŠ” ì¤„ë°”ê¿ˆ
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleSubmit(e);
        }
    };

    const handleFileUpload = (e) => {
        const selected = Array.from(e.target.files || []);
        const filtered = selected.filter((file) => {
            if (file.size > 5 * 1024 * 1024) {
                alert(`${file.name} ì€(ëŠ”) 5MBë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤.`);
                return false;
            }
            return true;
        });
        setFiles((prev) => [...prev, ...filtered]);
    };

    const removeFile = (index) => {
        setFiles((prev) => prev.filter((_, i) => i !== index));
    };

    // OpenAI messages í¬ë§·ìœ¼ë¡œ ë³€í™˜
    const buildOpenAIMessages = (history) => {
        if (!history) return [];
        return history
            .filter((m) => m.content && !m.error)
            .map((m) => ({
                role: m.role === 'user' ? 'user' : 'assistant',
                content: m.content,
            }));
    };

    // ì´ë¯¸ì§€ ê°ì§€
    const isImageFileName = (text) => {
        return /\.(jpg|jpeg|png|gif|webp|bmp)$/i.test(text);
    };

    // íŒŒì¼ ë‹¤ìš´ë¡œë“œ
    const isNormalFile = (filename) => {
        return /\.(pdf|hwp|docx?|xlsx?|zip|txt)$/i.test(filename);
    };

    // AI ë‹µë³€ ìŠ¤íŠ¸ë¦¬ë° íš¨ê³¼
    const streamAiResponse = (chatId, fullText) => {
        let index = 0;
        const step = 3;  // í•œ ë²ˆì— ì¶”ê°€ë˜ëŠ” ê¸€ì ìˆ˜
        const delay = 15; // ê°„ê²©(ms)

        const intervalId = setInterval(() => {
            index += step;

            setChatRooms((prevRooms) => {
                const room = prevRooms[chatId];
                if (!room || !room.history || room.history.length === 0) {
                    clearInterval(intervalId);
                    return prevRooms;
                }

                const history = [...room.history];
                const lastIndex = history.length - 1;
                const lastMsg = { ...history[lastIndex] };

                if (lastMsg.role !== 'ai' && lastMsg.role !== 'assistant') {
                    clearInterval(intervalId);
                    return prevRooms;
                }

                lastMsg.content = fullText.slice(0, index);
                lastMsg.loading = false;
                history[lastIndex] = lastMsg;

                // ì™„ë£Œ ì‹œ ì¸í„°ë²Œ ì •ë¦¬
                if (index >= fullText.length) {
                    clearInterval(intervalId);
                }

                return {
                    ...prevRooms,
                    [chatId]: {
                        ...room,
                        history,
                    },
                };
            });

            // ë§¤ ìŠ¤í…ë§ˆë‹¤ ìŠ¤í¬ë¡¤ ì•„ë˜ë¡œ
            scrollToBottom();
        }, delay);
    };

    // ë©”ì‹œì§€ ì „ì†¡ + AI ì‘ë‹µ
    const sendMessage = async (userMessage, chatId) => {
        setLoading(true);

        const currentHistory = chatRooms[chatId]?.history || [];
        const userHistory = [...currentHistory, { role: 'user', content: userMessage }];

        // ë¨¼ì € í”„ë¡ íŠ¸ì— user + ë¹ˆ ai ë©”ì‹œì§€ ì„¸íŒ…
        setChatRooms((prevRooms) => ({
            ...prevRooms,
            [chatId]: {
                ...(prevRooms[chatId] || { title: 'ìƒˆ ì±„íŒ…' }),
                history: [
                    ...userHistory,
                    {
                        role: 'ai',
                        content: '',
                        loading: true,
                    },
                ],
            },
        }));

        try {
            const messagesForApi = buildOpenAIMessages(userHistory);

            const response = await axios.post(CHAT_API_URL, {
                messages: messagesForApi,
            });

            const aiResponse = response.data?.response || '';

            // ìŠ¤íŠ¸ë¦¬ë° ì‹œì‘
            streamAiResponse(chatId, aiResponse);
        } catch (error) {
            console.error('API í†µì‹  ì˜¤ë¥˜:', error);
            // ë§ˆì§€ë§‰ ai ë©”ì‹œì§€ë¥¼ ì—ëŸ¬ë¡œ êµì²´
            setChatRooms((prevRooms) => {
                const room = prevRooms[chatId];
                if (!room || !room.history || room.history.length === 0) {
                    return prevRooms;
                }
                const history = [...room.history];
                const lastIndex = history.length - 1;
                history[lastIndex] = {
                    role: 'ai',
                    content: 'âŒ ì˜¤ë¥˜ ë°œìƒ: ì‘ë‹µì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.',
                    error: true,
                    loading: false,
                };
                return {
                    ...prevRooms,
                    [chatId]: {
                        ...room,
                        history,
                    },
                };
            });
        } finally {
            setLoading(false);
        }
    };

    const handleSubmit = (e) => {
        e.preventDefault();
        if (!urlChatId) return;
        if (loading) return;
        if (!message.trim() && files.length === 0) return;

        let userMessage = message.trim();

        // íŒŒì¼ì´ ìˆì„ ê²½ìš°, ë©”ì‹œì§€ì— íŒŒì¼ ì´ë¦„ë“¤ì„ ê°™ì´ í¬í•¨
        if (files.length > 0) {
            const fileNames = files.map((f) => f.name).join(', ');
            const fileText = `\n\n[ì²¨ë¶€ íŒŒì¼: ${fileNames}]`;
            userMessage = userMessage ? userMessage + fileText : fileText;
        }

        setMessage('');
        setFiles([]);

        sendMessage(userMessage, urlChatId);
    };

    const handleCopy = async (text) => {
        try {
            await navigator.clipboard.writeText(text);
        } catch (err) {
            console.error('ë³µì‚¬ ì‹¤íŒ¨:', err);
        }
    };

    // ëŒ€í™” ìš”ì•½
    const handleSummarize = async () => {
        if (!urlChatId) return;
        const room = chatRooms[urlChatId];
        const history = room?.history || [];
        if (history.length === 0) return;
        if (loading) return;

        setLoading(true);

        const summaryPrompt =
            'ì§€ê¸ˆê¹Œì§€ì˜ ì´ ëŒ€í™”ë¥¼ 5ì¤„ ì´ë‚´ì˜ í•œêµ­ì–´ë¡œ í•µì‹¬ë§Œ ìš”ì•½í•´ì¤˜. ì½”ë“œë‚˜ íŒŒì¼ ë‚´ìš©ì€ ê°„ë‹¨íˆ ì–¸ê¸‰ë§Œ í•´ì¤˜.';

        const messagesForApi = [
            ...buildOpenAIMessages(history),
            { role: 'user', content: summaryPrompt },
        ];

        // ìš”ì•½ ìë¦¬ ë¯¸ë¦¬ ì¶”ê°€
        setChatRooms((prevRooms) => {
            const curRoom = prevRooms[urlChatId];
            if (!curRoom) return prevRooms;
            return {
                ...prevRooms,
                [urlChatId]: {
                    ...curRoom,
                    history: [
                        ...curRoom.history,
                        {
                            role: 'ai',
                            content: 'ğŸ“ ìš”ì•½ ìƒì„± ì¤‘...',
                            loading: true,
                        },
                    ],
                },
            };
        });

        try {
            const response = await axios.post(CHAT_API_URL, {
                messages: messagesForApi,
            });
            const aiSummary = response.data?.response || '';

            setChatRooms((prevRooms) => {
                const curRoom = prevRooms[urlChatId];
                if (!curRoom || !curRoom.history || curRoom.history.length === 0) {
                    return prevRooms;
                }
                const historyArr = [...curRoom.history];
                const lastIndex = historyArr.length - 1;
                historyArr[lastIndex] = {
                    role: 'ai',
                    content: `ğŸ“ ìš”ì•½\n\n${aiSummary}`,
                    loading: false,
                };
                return {
                    ...prevRooms,
                    [urlChatId]: {
                        ...curRoom,
                        history: historyArr,
                    },
                };
            });
        } catch (error) {
            console.error('ìš”ì•½ ìƒì„± ì˜¤ë¥˜:', error);
            setChatRooms((prevRooms) => {
                const curRoom = prevRooms[urlChatId];
                if (!curRoom || !curRoom.history || curRoom.history.length === 0) {
                    return prevRooms;
                }
                const historyArr = [...curRoom.history];
                const lastIndex = historyArr.length - 1;
                historyArr[lastIndex] = {
                    role: 'ai',
                    content: 'âŒ ìš”ì•½ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
                    loading: false,
                    error: true,
                };
                return {
                    ...prevRooms,
                    [urlChatId]: {
                        ...curRoom,
                        history: historyArr,
                    },
                };
            });
        } finally {
            setLoading(false);
        }
    };

    const renderChats = () => {
        if (!currentChats || currentChats.length === 0) {
            return <div className="empty_state">ì±„íŒ… ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>;
        }
        return currentChats.map((chat, index) => {
            const link = !chat.loading ? extractFirstUrl(chat.content) : null;
            return (
                <div
                    key={index}
                    className={`chat_message chat_${chat.role} ${chat.loading ? 'loading' : ''}`}>
                    <strong>{chat.role === 'user' ? 'ë‚˜' : 'AI'}</strong>
                    <div className="bubble">
                        {chat.loading ? (
                            <TypingDots />
                        ) : (
                            <>
                                {/* 1) ì´ë¯¸ì§€ íŒŒì¼ */}
                                {isImageFileName(chat.content.trim()) && (
                                    <img
                                        src={chat.content.trim()}
                                        alt="ì—…ë¡œë“œ ì´ë¯¸ì§€"
                                        className="chat_image_preview"
                                        onClick={() => setPreviewImage(chat.content.trim())}
                                    />
                                )}

                                {/* 2) ì¼ë°˜ íŒŒì¼ ë‹¤ìš´ë¡œë“œ */}
                                {isNormalFile(chat.content.trim()) && (
                                    <div className="file_download_wrap">
                                        <span className="file_name">{chat.content.trim()}</span>
                                        <a
                                            href={chat.content.trim()}
                                            download
                                            className="file_download_btn"
                                        >
                                            ë‹¤ìš´ë¡œë“œ
                                        </a>
                                    </div>
                                )}

                                {/* 3) ê·¸ ì™¸: ì¼ë°˜ í…ìŠ¤íŠ¸ + ì½”ë“œë¸”ëŸ­ */}
                                {!isImageFileName(chat.content.trim()) &&
                                    !isNormalFile(chat.content.trim()) && (
                                        <>
                                            {/* [ìˆ˜ì •] chat.roleì„ 3ë²ˆì§¸ ì¸ìë¡œ ì¶”ê°€! */}
                                            {renderRichText(chat.content, handleCopy, chat.role)}

                                            {link && (
                                                <a className="chat_link_btn" href={link} target="_blank">
                                                    ë°”ë¡œê°€ê¸°
                                                </a>
                                            )}
                                        </>
                                    )}
                            </>
                        )}
                    </div>
                </div>
            );
        });
    };

    useEffect(() => {
        if (text) {
            // ê¸°ì¡´ ë©”ì‹œì§€ì— ê³µë°±ì„ ë‘ê³  ì´ì–´ ë¶™ì„
            setMessage((prev) => (prev ? prev + " " + text : text));

            // ì¤‘ìš”: í•œ ë²ˆ ë°˜ì˜ëœ í…ìŠ¤íŠ¸ëŠ” í›… ìƒíƒœì—ì„œ ì§€ì›Œì¤˜ì•¼ ì¤‘ë³µ ì…ë ¥ì´ ì•ˆ ë¨
            setText('');
        }
    }, [text, setText]);

    return (
        <section className="section_wrap">
            <div className="ChatRoom_body_wrap">
                <div className="chat_summary_fixed">
                    <button
                        type="button"
                        onClick={handleSummarize}
                        disabled={loading || !currentChats || currentChats.length === 0}>
                        ğŸ“ ëŒ€í™” ìš”ì•½
                    </button>
                </div>
                <div className="chat_container">
                    {showScrollDown && (
                        <button className="scroll_down_btn" onClick={scrollToBottom}>
                            <span className="material-symbols-outlined">arrow_downward</span>
                        </button>
                    )}
                    <div className="chat_toolbar">
                    </div>
                    {/* ëŒ€í™” ê¸°ë¡ */}
                    <div className="chat_history_wrap" ref={scrollRef}>
                        {renderChats()}
                    </div>
                    {/* ì…ë ¥/íŒŒì¼ ì˜ì—­ */}
                    <div
                        className={`input_select_wrap ${isDragging ? 'dragging' : ''}`}
                        onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}
                        onDragLeave={() => setIsDragging(false)}
                        onDrop={(e) => {
                            e.preventDefault();
                            setIsDragging(false);
                            const dropped = Array.from(e.dataTransfer.files || []);
                            const filtered = dropped.filter((file) => {
                                if (file.size > 5 * 1024 * 1024) {
                                    alert('5MB ì´í•˜ íŒŒì¼ë§Œ ì—…ë¡œë“œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                                    return false;
                                }
                                return true;
                            });
                            setFiles((prev) => [...prev, ...filtered]);
                        }}
                    >
                        {/* íŒŒì¼ ë¯¸ë¦¬ë³´ê¸° */}
                        {files.length > 0 && (
                            <div className="file_preview_area">
                                {files.map((file, idx) => {
                                    const isImage = file.type.startsWith('image/');
                                    const previewURL = isImage ? URL.createObjectURL(file) : null;
                                    const type = file.type;
                                    let icon = '/images/icon_file.png';
                                    if (type.includes('pdf')) icon = '/images/icon_pdf.png';
                                    else if (
                                        type.includes('word') ||
                                        type.includes('msword') ||
                                        type.includes('doc')
                                    )
                                        icon = '/images/icon_doc.png';
                                    else if (
                                        type.includes('excel') ||
                                        type.includes('spreadsheet') ||
                                        type.includes('xls')
                                    )
                                        icon = '/images/icon_excel.png';
                                    else if (type.includes('hwp')) icon = '/images/icon_hwp.png';

                                    return (
                                        <div className="file_item" key={idx}>
                                            {isImage ? (
                                                <img
                                                    className="thumb"
                                                    src={previewURL}
                                                    alt={file.name}
                                                    onClick={() => setPreviewImage(previewURL)}
                                                    style={{ cursor: 'pointer' }}
                                                />
                                            ) : (
                                                <img className="file_icon" src={icon} alt="file icon" />
                                            )}
                                            <span className="file_name">{file.name}</span>
                                            <button
                                                type="button"
                                                className="file_remove_btn"
                                                onClick={() => removeFile(idx)}
                                            >
                                                Ã—
                                            </button>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                        {/* ì…ë ¥ í¼ */}
                        <form onSubmit={handleSubmit}>
                            <div className="input_row">
                                {/* íŒŒì¼ ì¶”ê°€ ë²„íŠ¼ */}
                                <label className="add_btn">
                                    <span className="material-symbols-outlined">attach_file</span>
                                    <input
                                        type="file"
                                        multiple
                                        style={{ display: 'none' }}
                                        onChange={handleFileUpload}
                                    />
                                </label>

                                {/* í…ìŠ¤íŠ¸ ì…ë ¥ */}
                                <textarea
                                    name="message"
                                    ref={textareaRef}
                                    value={message}
                                    onChange={handleInputChange}
                                    onKeyDown={handleKeyDown}
                                    placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”â€¦"
                                />

                                <button
                                    type="button"
                                    className={`mic_btn ${isListening ? 'active' : ''}`}
                                    onClick={isListening ? stopListening : startListening}
                                >
                                    <span className="material-symbols-outlined">
                                        {isListening ? 'mic_off' : 'mic'}
                                    </span>
                                </button>

                                {/* ì „ì†¡ ë²„íŠ¼ */}
                                <button
                                    type="submit"
                                    className="send_btn"
                                    disabled={loading || (!message.trim() && files.length === 0)}
                                >
                                    <span className="material-symbols-outlined">send</span>
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
            {/* ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° ëª¨ë‹¬ */}
            {previewImage && (
                <div className="image_modal_dim" onClick={() => setPreviewImage(null)}>
                    <div className="image_modal_wrap" onClick={(e) => e.stopPropagation()}>
                        <img src={previewImage} alt="ë¯¸ë¦¬ë³´ê¸°" />
                    </div>
                </div>
            )}

        </section>
    );
};

export default ChatRoom;


/* ==========================================================================
   File: Layout.jsx
   ========================================================================== */
import { Outlet } from "react-router-dom";
import { useState, useEffect, useRef } from 'react';
import Aside from './Layout/Aside';
import Header from './Layout/Header';
import Footer from './Layout/Footer';
import SettingModal from "./SettingModal";
import '../css/Layout.scss';

const Layout = () => {
  const [activeChatId, setActiveChatId] = useState(null);
  const [chatRooms, setChatRooms] = useState({});
  const [isCollapsed, setIsCollapsed] = useState(false);
  const [showSettingModal, setShowSettingModal] = useState(false);
  const scrollAreaRef = useRef(null);

  /* ì•± ë¡œë“œ ì‹œ LocalStorage ë¶ˆëŸ¬ì˜¤ê¸° */
  useEffect(() => {
    const saved = localStorage.getItem("chatRooms");
    if (saved) {
      const parsed = JSON.parse(saved);
      setChatRooms(parsed);
    }
  }, []);

  /* chatRooms ë°”ë€” ë•Œë§ˆë‹¤ ìë™ ì €ì¥ */
  useEffect(() => {
    localStorage.setItem("chatRooms", JSON.stringify(chatRooms));
  }, [chatRooms]);

  const chatProps = {
    activeChatId,
    setActiveChatId,
    chatRooms,
    setChatRooms,
    isCollapsed,
    setIsCollapsed,
    showSettingModal,
    setShowSettingModal,
    scrollAreaRef
  };

  return (
    <div className={`layout ${isCollapsed ? "collapsed" : ""}`}>
      <Aside {...chatProps} />
      <div className="content_wrap">
        <Header isCollapsed={isCollapsed} setIsCollapsed={setIsCollapsed} />
        <main className="main" ref={scrollAreaRef}>
          <Outlet context={chatProps} />
        </main>
        <Footer />
        {/* Setting Modal */}
        {showSettingModal && (
          <SettingModal setShowSettingModal={setShowSettingModal} />
        )}
      </div>
    </div>
  );
};

export default Layout;


/* ==========================================================================
   File: main.jsx
   ========================================================================== */
// src/pages/main.jsx
import '../css/main.scss';
import { useState, useRef, useEffect, useCallback } from 'react';
import { useOutletContext, useNavigate } from 'react-router-dom';
import useAutosizeTextarea from '../component/useAutosizeTextarea';
import useSpeechToText from '../component/useSpeechToText';
import axios from 'axios';

// ì œëª© ìë™ ìƒì„± í•¨ìˆ˜ (ChatRoomê³¼ ë™ì¼ ê·œì¹™)
const generateChatTitle = (text) => {
    const first = text.split('\n')[0].trim();
    if (!first) return 'ìƒˆ ì±„íŒ…';
    return first.length > 30 ? first.slice(0, 30) + 'â€¦' : first;
};

const CHAT_API_URL = 'http://localhost:3001/api/chat';

const Home = () => {
    const {
        activeChatId,
        setActiveChatId,
        chatRooms,
        setChatRooms,
    } = useOutletContext();

    const navigate = useNavigate();
    const textareaRef = useRef(null);

    const [message, setMessage] = useState('');
    const [loading, setLoading] = useState(false);
    const [files, setFiles] = useState([]);
    const [isDragging, setIsDragging] = useState(false);
    const [previewImage, setPreviewImage] = useState(null);
    const { text, setText, isListening, startListening, stopListening } = useSpeechToText();

    useAutosizeTextarea(textareaRef, message);

    const handleInputChange = useCallback((e) => {
        setMessage(e.target.value);
    }, []);

    // íŒŒì¼ ì—…ë¡œë“œ í•¸ë“¤ëŸ¬
    const handleFileUpload = (e) => {
        const selected = Array.from(e.target.files || []);
        const filtered = selected.filter((file) => {
            if (file.size > 5 * 1024 * 1024) {
                alert(`${file.name} ì€(ëŠ”) 5MBë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤.`);
                return false;
            }
            return true;
        });
        setFiles((prev) => [...prev, ...filtered]);
    };

    const removeFile = (index) => {
        setFiles((prev) => prev.filter((_, i) => i !== index));
    };

    const handleKeyDown = (e) => {
        // Enter â†’ ì „ì†¡ / Shift+Enter â†’ ì¤„ë°”ê¿ˆ
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleSubmit(e);
        }
    };

    // --- ìƒˆ ì±„íŒ… ìƒì„± + ì „ì†¡ ---
    const sendMessage = async (userMessage, chatId) => {
        setLoading(true);

        const newHistory = [{ role: 'user', content: userMessage }];

        // â–¼ title ì˜¤íƒ€(ttitle) â†’ titleë¡œ ìˆ˜ì •í•¨
        setChatRooms((prev) => ({
            ...prev,
            [chatId]: {
                title: generateChatTitle(userMessage),
                history: [
                    ...newHistory,
                    {
                        role: 'ai',
                        content: 'ì‘ë‹µ ìƒì„± ì¤‘...',
                        loading: true,
                    },
                ],
            },
        }));

        setActiveChatId(chatId);

        try {
            const response = await axios.post(CHAT_API_URL, {
                messages: newHistory,
            });

            const aiResponse = response.data?.response || '';

            setChatRooms((prev) => {
                const finalHistory = [
                    ...newHistory,
                    {
                        role: 'ai',
                        content: aiResponse,
                        loading: false,
                    },
                ];

                return {
                    ...prev,
                    [chatId]: {
                        ...prev[chatId],
                        history: finalHistory,
                    },
                };
            });
        } catch (err) {
            console.error('API ì˜¤ë¥˜:', err);

            setChatRooms((prev) => ({
                ...prev,
                [chatId]: {
                    ...prev[chatId],
                    history: [
                        ...newHistory,
                        {
                            role: 'ai',
                            content: 'âŒ ì˜¤ë¥˜ ë°œìƒ: ì‘ë‹µì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
                            error: true,
                            loading: false,
                        },
                    ],
                },
            }));
        } finally {
            setLoading(false);
        }
    };

    // --- í¼ submit ---
    const handleSubmit = (e) => {
        e.preventDefault();
        if (loading) return;
        if (!message.trim()) return;

        const chatId = Date.now().toString();
        const userMessage = message.trim();

        setMessage('');

        // ChatRoomìœ¼ë¡œ íŒŒì¼ ì „ë‹¬
        navigate(`/chat/${chatId}`, {
            state: {
                initialFiles: files,
            },
        });

        setFiles([]);

        sendMessage(userMessage, chatId);
    };

    // ìŒì„± ì¸ì‹ëœ í…ìŠ¤íŠ¸ê°€ ìƒê¸°ë©´ message ìƒíƒœ ì—…ë°ì´íŠ¸
    useEffect(() => {
        if (text) {
            // ê¸°ì¡´ ë©”ì‹œì§€ì— ê³µë°±ì„ ë‘ê³  ì´ì–´ ë¶™ì„
            setMessage((prev) => (prev ? prev + " " + text : text));

            // ì¤‘ìš”: í•œ ë²ˆ ë°˜ì˜ëœ í…ìŠ¤íŠ¸ëŠ” í›… ìƒíƒœì—ì„œ ì§€ì›Œì¤˜ì•¼ ì¤‘ë³µ ì…ë ¥ì´ ì•ˆ ë¨
            setText('');
        }
    }, [text, setText]);

    return (
        <section className="section_wrap">
            <div className="main_body_wrap">
                <div className="logo" style={{ marginBottom: '5px' }}>
                    <h1>DoAi</h1>
                </div>

                {/* ë“œë˜ê·¸ ì˜ì—­ */}
                <div
                    className={`input_select_wrap ${isDragging ? 'dragging' : ''}`}
                    onDragOver={(e) => {
                        e.preventDefault();
                        setIsDragging(true);
                    }}
                    onDragLeave={() => setIsDragging(false)}
                    onDrop={(e) => {
                        e.preventDefault();
                        setIsDragging(false);

                        const dropped = Array.from(e.dataTransfer.files || []);
                        const filtered = dropped.filter((file) => {
                            if (file.size > 5 * 1024 * 1024) {
                                alert('5MB ì´í•˜ì˜ íŒŒì¼ë§Œ ì—…ë¡œë“œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                                return false;
                            }
                            return true;
                        });
                        setFiles((prev) => [...prev, ...filtered]);
                    }}
                >
                    {/* íŒŒì¼ ë¯¸ë¦¬ë³´ê¸° */}
                    {files.length > 0 && (
                        <div className="file_preview_area">
                            {files.map((file, idx) => {
                                const isImage = file.type.startsWith('image/');
                                const previewURL = isImage ? URL.createObjectURL(file) : null;

                                const type = file.type;
                                let icon = '/images/icon_file.png';
                                if (type.includes('pdf')) icon = '/images/icon_pdf.png';
                                else if (
                                    type.includes('word') ||
                                    type.includes('msword') ||
                                    type.includes('doc')
                                )
                                    icon = '/images/icon_doc.png';
                                else if (
                                    type.includes('excel') ||
                                    type.includes('spreadsheet') ||
                                    type.includes('xls')
                                )
                                    icon = '/images/icon_excel.png';
                                else if (type.includes('hwp')) icon = '/images/icon_hwp.png';

                                return (
                                    <div className="file_item" key={idx}>
                                        {isImage ? (
                                            <img
                                                className="thumb"
                                                src={previewURL}
                                                alt={file.name}
                                                onClick={() => setPreviewImage(previewURL)}
                                                style={{ cursor: 'pointer' }}
                                            />
                                        ) : (
                                            <img
                                                className="file_icon"
                                                src={icon}
                                                alt="file icon"
                                            />
                                        )}

                                        <span className="file_name">{file.name}</span>
                                        <button
                                            type="button"
                                            className="file_remove_btn"
                                            onClick={() => removeFile(idx)}
                                        >
                                            Ã—
                                        </button>
                                    </div>
                                );
                            })}
                        </div>
                    )}

                    {/* ì…ë ¥ì°½ */}
                    <form onSubmit={handleSubmit}>
                        <div className="input_row">
                            {/* íŒŒì¼ ì¶”ê°€ ë²„íŠ¼ */}
                            <label className="add_btn">
                                <span className="material-symbols-outlined">attach_file</span>
                                <input
                                    type="file"
                                    multiple
                                    style={{ display: 'none' }}
                                    onChange={handleFileUpload}
                                />
                            </label>

                            {/* í…ìŠ¤íŠ¸ ì…ë ¥ */}
                            <textarea
                                name="message"
                                value={message}
                                ref={textareaRef}
                                onChange={handleInputChange}
                                onKeyDown={handleKeyDown}
                                placeholder="ì ë‹¹íˆ ë¬¼ì–´ë³´ì„¸ìš”."
                            />

                            {/* ë§ˆì´í¬ ë²„íŠ¼ */}
                            <button
                                type="button"
                                className={`mic_btn ${isListening ? 'active' : ''}`}
                                onClick={isListening ? stopListening : startListening}
                            >
                                <span className="material-symbols-outlined">
                                    {isListening ? 'mic_off' : 'mic'}
                                </span>
                            </button>

                            {/* ì „ì†¡ ë²„íŠ¼ */}
                            <button
                                type="submit"
                                className="send_btn"
                                disabled={!message.trim() || loading}
                            >
                                <span className="material-symbols-outlined">send</span>
                            </button>
                        </div>
                    </form>
                </div>
            </div>

            {/* ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° ëª¨ë‹¬ */}
            {previewImage && (
                <div
                    className="image_modal_dim"
                    onClick={() => setPreviewImage(null)}
                >
                    <div
                        className="image_modal_wrap"
                        onClick={(e) => e.stopPropagation()}
                    >
                        <img src={previewImage} alt="ë¯¸ë¦¬ë³´ê¸°" />
                    </div>
                </div>
            )}
        </section>
    );
};

export default Home;


/* ==========================================================================
   File: Goodbye.jsx
   ========================================================================== */
// src/pages/Goodbye.jsx
import { Link } from 'react-router-dom';
import '../css/main.scss'; // ê¸°ì¡´ ìŠ¤íƒ€ì¼ ì¬ì‚¬ìš©

const Goodbye = () => {
    // ì¸ë¼ì¸ ìŠ¤íƒ€ì¼ë¡œ ê°„ë‹¨íˆ ë ˆì´ì•„ì›ƒ ì¡ê¸° (ê¸°ì¡´ ë³€ìˆ˜ í™œìš©)
    const containerStyle = {
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        alignItems: 'center',
        height: '100vh',
        background: 'var(--bg-main)', // ë©”ì¸ ë°°ê²½ìƒ‰
        color: 'var(--text-primary)', // ë©”ì¸ í°íŠ¸ìƒ‰
        textAlign: 'center'
    };

    const buttonStyle = {
        marginTop: '30px',
        padding: '12px 24px',
        background: 'var(--submit-btn)', // ì „ì†¡ ë²„íŠ¼ìƒ‰ í™œìš©
        color: '#fff',
        borderRadius: '8px',
        textDecoration: 'none',
        fontWeight: 'bold',
        fontSize: '16px',
        display: 'inline-flex',
        alignItems: 'center',
        gap: '8px'
    };

    return (
        <div style={containerStyle}>
            <span 
                className="material-symbols-outlined" 
                style={{ fontSize: '64px', marginBottom: '20px', color: 'var(--text-secondary)' }}
            >
                waving_hand
            </span>
            <h1 style={{ fontSize: '28px', marginBottom: '10px' }}>ì´ìš©í•´ ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤</h1>
            <p style={{ color: 'var(--text-secondary)', fontSize: '16px' }}>
                DoAiì™€ì˜ ëŒ€í™”ê°€ ì¦ê±°ìš°ì…¨ê¸°ë¥¼ ë°”ëë‹ˆë‹¤.<br />
                ì–¸ì œë“ ì§€ ë‹¤ì‹œ ëŒì•„ì˜¤ì„¸ìš”!
            </p>

            <Link to="/" style={buttonStyle}>
                <span className="material-symbols-outlined">restart_alt</span>
                ë‹¤ì‹œ ì‹œì‘í•˜ê¸°
            </Link>
        </div>
    );
};

export default Goodbye;


/* ==========================================================================
   File: Aside.jsx
   ========================================================================== */
import '../../css/Layout/Aside.scss';
import { Link } from 'react-router-dom';

const Aside = ({
  activeChatId,
  setActiveChatId,
  chatRooms,
  setChatRooms,
  isCollapsed,
  setShowSettingModal,
}) => {
  const chatRoomIds = Object.keys(chatRooms).reverse();

  const handleChatClick = (id) => {
    setActiveChatId(id);
  };

  const handleDeleteChat = (id) => {
    if (!window.confirm('ì´ ì±„íŒ…ì„ ì‚­ì œí• ê¹Œìš”?')) return;

    setChatRooms((prev) => {
      const next = { ...prev };
      delete next[id];
      return next;
    });

    if (activeChatId === id) {
      setActiveChatId(null);
    }
  };

  return (
    <aside className={`side_menu_wrap ${isCollapsed ? 'collapsed' : 'expanded'}`}>
      <div className="logo" style={{ marginTop: '5px' }}>
        <h3>DoAi</h3>
      </div>

      <div className="menu_wrap">
        {/* ìƒë‹¨ ì˜ì—­ */}
        <div className="menu_top_wrap chat_list_container">
          {/* í™ˆ ë²„íŠ¼ - ì˜ˆì „ì²˜ëŸ¼ btn_select_wrap ì‚¬ìš© */}
          <Link
            to="/"
            className="btn_select_wrap"
            onClick={() => setActiveChatId(null)}
          >
            <div className="btn_wrap">
              <span className="material-symbols-outlined">home</span>
            </div>
            <p>í™ˆ</p>
          </Link>

          <div className="chat_title">
            <span>ë‚´ ì±„íŒ… ëª©ë¡</span>
          </div>

          {/* ì±„íŒ… ëª©ë¡ - ìƒˆ êµ¬ì¡° (chat_item_row + chat_room_link) */}
          {chatRoomIds.map((id) => (
            <div className="chat_item_row" key={id}>
              <Link
                to={`/chat/${id}`}
                className={`chat_room_link ${id === activeChatId ? 'active' : ''}`}
                onClick={() => handleChatClick(id)}
              >
                <div className="btn_wrap">
                  <span className="material-symbols-outlined">edit_square</span>
                </div>
                <p>{chatRooms[id].title}</p>
              </Link>

              {/* ì‚­ì œ ë²„íŠ¼ (hover ì‹œ ë…¸ì¶œ) */}
              <button
                type="button"
                className="chat_delete_btn"
                onClick={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  handleDeleteChat(id);
                }}
              >
                <span className="material-symbols-outlined">delete</span>
              </button>
            </div>
          ))}
        </div>

        {/* í•˜ë‹¨ ì„¤ì • */}
        <div className="menu_bottom_wrap">
          <Link
            to="#"
            className="btn_select_wrap settings"
            onClick={(e) => {
              e.preventDefault();
              setShowSettingModal(true);
            }}
          >
            <span className="material-symbols-outlined">settings</span>
          </Link>
        </div>
      </div>
    </aside>
  );
};

export default Aside;